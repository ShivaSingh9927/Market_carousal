import os, io, asyncio, pandas as pd, traceback
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from orchestrator import orchestrator 
from vram_manager import purge as purge_vram 
from dotenv import load_dotenv

# --- CONFIG ---
load_dotenv()
TOKEN, MY_ID = os.getenv("TELEGRAM_TOKEN"), int(os.getenv("MY_CHAT_ID"))
BASE_PATH = "/nuvodata/User_data/shiva/Market_carousal"
CSV_PATH = os.path.join(BASE_PATH, "marketing_plan.csv")
HISTORY_PATH = os.path.join(BASE_PATH, "topic_history.log")
OUTPUT_DIR = os.path.join(BASE_PATH, "output_slides")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != MY_ID: return
    keyboard = [[InlineKeyboardButton("ğŸ” Scout Market & Plan", callback_data='cmd_plan')],
                [InlineKeyboardButton("ğŸš€ Run Full Factory Batch", callback_data='cmd_generate')]]
    await update.message.reply_text(
        "ğŸ’ **Nueralogic Command Center**\nType any changes to refine the plan.", 
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_chat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Unified handler: Chat first, Plan second."""
    user_msg = update.message.text
    
    # 1. Heuristic: Is the user explicitly asking for a plan/calendar?
    planning_keywords = ["plan", "calendar", "schedule", "generate", "create"]
    is_planning_request = any(k in user_msg.lower() for k in planning_keywords)

    if is_planning_request:
        await update.message.reply_text("ğŸ•µï¸â€â™‚ï¸ **Understood. Activating Strategist Node...**")
        await run_planning_flow(update, context, user_msg)
    else:
        # 2. Conversational Mode
        await update.message.reply_text("ğŸ¤” **Analyzing...**")
        
        # Use a simple chain to answer the question
        try:
            # Re-use the LLM defined in orchestrator (import it or redefine)
            from orchestrator import llm, web_scout, get_rag_context
            
            # 1. Get Company Context (RAG)
            company_context = get_rag_context("Nueralogic capabilities case studies")
            
            # 2. Get External Context (Web)
            research_context = ""
            if "?" in user_msg:
                 research_context = web_scout(user_msg)
            
            # 3. Consultant Prompt
            system_prompt = f"""You are the Head of Strategy at Nueralogic.
            
            COMPANY INTEL:
            {company_context}
            
            EXTERNAL INTEL:
            {research_context}
            
            Answer the user's question with authority, referencing our specific capabilities where relevant.
            Keep it brief and conversational.
            """
            
            response = llm.invoke(f"System: {system_prompt}\n\nUser Question: {user_msg}")
            
            await update.message.reply_text(response.content)
            
        except Exception as e:
            await update.message.reply_text(f"âš ï¸ Chat Error: {e}")

async def run_planning_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, user_feedback=""):
    """The original planning logic, now refactored into a specific function."""
    # Determine if this is a button click or a text message
    is_callback = update.callback_query is not None
    
    if is_callback:
        query = update.callback_query
        await query.answer()
        try:
            await query.edit_message_text("ğŸ•µï¸â€â™‚ï¸ **Agent is working...**")
        except:
            pass
    
    try:
        past_topics = []
        if os.path.exists(HISTORY_PATH):
            with open(HISTORY_PATH, 'r') as f:
                past_topics = f.read().splitlines()[-15:]

        # Run the Orchestrator
        result = orchestrator.invoke({
            "past_topics": past_topics,
            "scout_report": "",
            "kb_context": "",
            "proposed_calendar": "",
            "user_approval": False,
            "errors": [],
            "user_feedback": user_feedback 
        })
        
        csv_data = result.get("proposed_calendar", "")
        if not csv_data:
            raise ValueError("No calendar data generated by strategist.")

        with open(CSV_PATH, 'w') as f: 
            f.write(csv_data)

        # --- HARDENED PARSING ---
        try:
            # First try: Standard Parse
            df = pd.read_csv(io.StringIO(csv_data), quotechar='"', skipinitialspace=True, sep=None, engine='python')
        except Exception:
            print(f"âš ï¸ CSV Parse Error! Raw Data:\n{csv_data}")
            # Fallback: Skip bad lines to keep the bot alive
            df = pd.read_csv(io.StringIO(csv_data), quotechar='"', skipinitialspace=True, sep=None, engine='python', on_bad_lines='skip')
        
        summary = "ğŸ“‹ **Updated Strategy:**\n\n"
        for i in range(min(len(df), 5)):
            row = df.iloc[i]
            # Use iloc safely to avoid 'Series.__getitem__' deprecation warning
            day = row.iloc[0] if len(row) > 0 else f"Day {i+1}"
            framework = row.iloc[1] if len(row) > 1 else "AIDA"
            angle = row.iloc[3] if len(row) > 3 else "Technical Deep Dive"
            summary += f"ğŸ”¹ **{day} ({framework})**: {angle}\n"

        # Generate Dynamic Buttons: Full Week + Individual Days
        keyboard = []
        # Option 1: Full Batch
        keyboard.append([InlineKeyboardButton("ğŸš€ Generate Full Week", callback_data='cmd_generate_all')])
        
        # Option 2: Individual Days
        day_buttons = []
        for i in range(len(df)):
            row = df.iloc[i]
            day_name = str(row.iloc[0]).strip()
            # Callback data: cmd_generate_DayName
            day_buttons.append(InlineKeyboardButton(f"ğŸ“… {day_name}", callback_data=f'cmd_generate_{day_name}'))
            
            # Group into rows of 2
            if len(day_buttons) == 2:
                keyboard.append(day_buttons)
                day_buttons = []
        
        if day_buttons:
             keyboard.append(day_buttons)

        # Option 3: Re-plan
        keyboard.append([InlineKeyboardButton("ğŸ” Re-Scout & Plan", callback_data='cmd_plan')])
        
        # Determine where to send the response
        if is_callback:
            await query.message.reply_text(summary, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
        else:
            await update.message.reply_text(summary, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')

    except Exception as e:
        print(f"Planning Error: {traceback.format_exc()}")
        error_msg = f"âŒ Error: {str(e)}"
        if is_callback:
            await query.message.reply_text(error_msg)
        else:
            await update.message.reply_text(error_msg)

async def handle_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data # e.g. cmd_generate_all or cmd_generate_Monday
    target_day = None
    
    if data.startswith("cmd_generate_") and data != "cmd_generate_all":
        target_day = data.replace("cmd_generate_", "")
    
    if not os.path.exists(CSV_PATH):
        await query.edit_message_text("âŒ No plan found. Run Scout & Plan first.")
        return

    purge_vram()
    
    # Reload CSV to get the day list
    try:
        df = pd.read_csv(CSV_PATH, sep=None, engine='python')
    except:
        df = pd.read_csv(CSV_PATH, sep=None, engine='python', on_bad_lines='skip')
    
    # Filter days if specific day requested
    if target_day:
        # Fuzzy match the day column
        day_col = df.columns[0]
        # Check if target_day exists in the column
        mask = df[day_col].astype(str).str.strip().str.lower() == target_day.strip().lower()
        if not mask.any():
             await query.message.reply_text(f"âŒ Day '{target_day}' not found in plan.")
             return
        days = df[mask].iloc[:, 0].unique()
        await query.edit_message_text(f"âš™ï¸ **Factory Online.** Generating {target_day}...")
    else:
        days = df.iloc[:, 0].unique()
        await query.edit_message_text(f"âš™ï¸ **Factory Online.** Processing Full Week ({len(days)} days)...")

    for day in days:
        day_str = str(day).strip()
        purge_vram()
        
        # Execute run_pipeline.py
        process = await asyncio.create_subprocess_exec(
            'python', os.path.join(BASE_PATH, 'run_pipeline.py'), '--day', day_str,
            stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )
        await process.communicate()
        
        clean_folder = day_str.replace(" ", "_")
        pdf_path = os.path.join(OUTPUT_DIR, clean_folder, "Nueralogic_Carousel.pdf")
        
        if os.path.exists(pdf_path):
            try:
                with open(pdf_path, 'rb') as f:
                    await context.bot.send_document(
                        chat_id=MY_ID, 
                        document=f, 
                        caption=f"ğŸš€ Day {day_str} Content is Ready.",
                        read_timeout=60, 
                        write_timeout=60, 
                        connect_timeout=60
                    )
            except Exception as e:
                print(f"âš ï¸ PDF Delivery Failed for {day_str}: {e}")
        
        # Send Captions
        caption_path = os.path.join(OUTPUT_DIR, clean_folder, "social_captions.txt")
        if os.path.exists(caption_path):
            try:
                with open(caption_path, 'r') as f:
                    captions = f.read()
                    if len(captions) > 4000:
                        captions = captions[:4000] + "... (truncated)"
                    
                    await context.bot.send_message(
                        chat_id=MY_ID,
                        text=f"ğŸ“ **Social Media Posts for {day_str}**\n\n{captions}",
                        parse_mode='Markdown'
                    )
            except Exception as e:
                 print(f"âš ï¸ Caption Delivery Failed for {day_str}: {e}")
        
    await query.message.reply_text("ğŸ’ **Generation Complete.**")

def main():
    app = Application.builder().token(TOKEN).read_timeout(60).write_timeout(60).connect_timeout(60).build()
    
    # Handlers
    app.add_handler(CommandHandler("start", start))
    
    # Button Handlers
    app.add_handler(CallbackQueryHandler(run_planning_flow, pattern='^cmd_plan$'))
    app.add_handler(CallbackQueryHandler(handle_generation, pattern='^cmd_generate'))
    
    # Message handler for typed feedback or chat
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_chat))
    
    print("ğŸš€ Bot is polling...")
    app.run_polling()

if __name__ == "__main__":
    main()